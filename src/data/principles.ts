export interface Principle {
  id: string;
  name: string;
  category: string;
  shortDesc: string;
  description: string;
  useCases: string[];
  pros: string[];
  cons: string[];
}

export const categories = [
  "Scalability",
  "Reliability",
  "Data Management",
  "Communication",
  "Caching",
  "Security",
  "Architecture",
  "Performance",
];

export const principles: Principle[] = [
  {
    id: "load-balancing",
    name: "Load Balancing",
    category: "Scalability",
    shortDesc: "Distribute traffic across multiple servers",
    description: "Load balancing distributes incoming network traffic across multiple servers to ensure no single server bears too much demand. This improves responsiveness and increases availability of applications.",
    useCases: ["High-traffic websites", "API gateways", "Microservices"],
    pros: ["Improved availability", "Better performance", "Scalability"],
    cons: ["Added complexity", "Single point of failure if not redundant", "Session management challenges"],
  },
  {
    id: "horizontal-scaling",
    name: "Horizontal Scaling",
    category: "Scalability",
    shortDesc: "Add more machines to handle increased load",
    description: "Horizontal scaling (scaling out) involves adding more machines to a pool of resources. Unlike vertical scaling, it allows for virtually unlimited growth by adding commodity hardware.",
    useCases: ["Web applications", "Distributed databases", "Containerized apps"],
    pros: ["Near-infinite scalability", "Cost-effective", "Fault tolerance"],
    cons: ["Data consistency challenges", "More complex architecture", "Network overhead"],
  },
  {
    id: "vertical-scaling",
    name: "Vertical Scaling",
    category: "Scalability",
    shortDesc: "Add more power to existing machines",
    description: "Vertical scaling (scaling up) means adding more resources like CPU, RAM, or storage to existing servers. It's simpler but has physical limitations.",
    useCases: ["Database servers", "Legacy applications", "Small-scale systems"],
    pros: ["Simple implementation", "No code changes needed", "Lower latency"],
    cons: ["Hardware limits", "Expensive", "Single point of failure"],
  },
  {
    id: "database-sharding",
    name: "Database Sharding",
    category: "Data Management",
    shortDesc: "Partition data across multiple databases",
    description: "Sharding splits large databases into smaller, faster, more manageable parts called shards. Each shard contains a subset of the total data.",
    useCases: ["Large-scale databases", "Multi-tenant systems", "Geographic distribution"],
    pros: ["Improved performance", "Horizontal scalability", "Reduced index size"],
    cons: ["Complex queries", "Rebalancing challenges", "Cross-shard transactions"],
  },
  {
    id: "database-replication",
    name: "Database Replication",
    category: "Data Management",
    shortDesc: "Copy data across multiple database servers",
    description: "Database replication involves copying and maintaining database objects in multiple databases. It improves data availability and read performance.",
    useCases: ["Read-heavy workloads", "Disaster recovery", "Geographic distribution"],
    pros: ["High availability", "Read scalability", "Backup strategy"],
    cons: ["Replication lag", "Consistency issues", "Storage costs"],
  },
  {
    id: "caching",
    name: "Caching",
    category: "Caching",
    shortDesc: "Store frequently accessed data in fast storage",
    description: "Caching stores copies of frequently accessed data in a faster storage layer. This reduces database load and improves response times significantly.",
    useCases: ["Web pages", "API responses", "Database queries"],
    pros: ["Faster response times", "Reduced database load", "Better user experience"],
    cons: ["Cache invalidation complexity", "Memory costs", "Stale data risk"],
  },
  {
    id: "cdn",
    name: "Content Delivery Network",
    category: "Caching",
    shortDesc: "Distribute content globally via edge servers",
    description: "A CDN is a geographically distributed network of proxy servers. It delivers content from locations closer to users, reducing latency.",
    useCases: ["Static assets", "Video streaming", "Global websites"],
    pros: ["Reduced latency", "High availability", "DDoS protection"],
    cons: ["Cost", "Cache invalidation", "Dynamic content challenges"],
  },
  {
    id: "message-queues",
    name: "Message Queues",
    category: "Communication",
    shortDesc: "Asynchronous communication between services",
    description: "Message queues enable asynchronous communication between services. They decouple producers from consumers and help handle traffic spikes.",
    useCases: ["Order processing", "Email notifications", "Data pipelines"],
    pros: ["Decoupling", "Reliability", "Traffic smoothing"],
    cons: ["Added latency", "Message ordering", "Complexity"],
  },
  {
    id: "event-driven",
    name: "Event-Driven Architecture",
    category: "Architecture",
    shortDesc: "Systems react to events as they occur",
    description: "Event-driven architecture uses events to trigger and communicate between decoupled services. It enables real-time responses and loose coupling.",
    useCases: ["Real-time analytics", "IoT systems", "Microservices"],
    pros: ["Loose coupling", "Scalability", "Real-time processing"],
    cons: ["Debugging complexity", "Event ordering", "Eventual consistency"],
  },
  {
    id: "microservices",
    name: "Microservices",
    category: "Architecture",
    shortDesc: "Decompose applications into small services",
    description: "Microservices architecture structures an application as a collection of loosely coupled, independently deployable services organized around business capabilities.",
    useCases: ["Large applications", "Teams at scale", "Continuous deployment"],
    pros: ["Independent deployment", "Technology flexibility", "Scalability"],
    cons: ["Distributed complexity", "Network latency", "Data consistency"],
  },
  {
    id: "api-gateway",
    name: "API Gateway",
    category: "Architecture",
    shortDesc: "Single entry point for all client requests",
    description: "An API gateway is a server that acts as the single entry point for a group of microservices. It handles requests, routing, composition, and protocol translation.",
    useCases: ["Microservices", "Mobile backends", "Third-party APIs"],
    pros: ["Centralized control", "Security", "Rate limiting"],
    cons: ["Single point of failure", "Added latency", "Complexity"],
  },
  {
    id: "circuit-breaker",
    name: "Circuit Breaker",
    category: "Reliability",
    shortDesc: "Prevent cascading failures in distributed systems",
    description: "The circuit breaker pattern prevents an application from repeatedly trying to execute an operation that's likely to fail, allowing it to continue without waiting for the fault to be fixed.",
    useCases: ["Microservices", "External API calls", "Database connections"],
    pros: ["Prevents cascading failures", "Fast failure", "Self-healing"],
    cons: ["Configuration complexity", "False positives", "State management"],
  },
  {
    id: "rate-limiting",
    name: "Rate Limiting",
    category: "Security",
    shortDesc: "Control the rate of requests to prevent abuse",
    description: "Rate limiting controls the number of requests a client can make in a given time period. It protects services from being overwhelmed and ensures fair usage.",
    useCases: ["Public APIs", "Authentication endpoints", "Resource-intensive operations"],
    pros: ["Prevents abuse", "Ensures fairness", "Protects resources"],
    cons: ["User experience impact", "Complexity", "Clock synchronization"],
  },
  {
    id: "eventual-consistency",
    name: "Eventual Consistency",
    category: "Data Management",
    shortDesc: "Data becomes consistent over time",
    description: "Eventual consistency guarantees that if no new updates are made, eventually all accesses will return the last updated value. It trades immediate consistency for availability.",
    useCases: ["Distributed databases", "DNS", "Social media feeds"],
    pros: ["High availability", "Low latency", "Partition tolerance"],
    cons: ["Stale reads", "Conflict resolution", "Complexity"],
  },
  {
    id: "cap-theorem",
    name: "CAP Theorem",
    category: "Data Management",
    shortDesc: "Choose two: Consistency, Availability, Partition tolerance",
    description: "The CAP theorem states that a distributed system can only provide two of three guarantees: Consistency, Availability, and Partition tolerance. Understanding this helps in making architectural decisions.",
    useCases: ["Database selection", "System design", "Trade-off analysis"],
    pros: ["Framework for decisions", "Clarity on trade-offs", "Design guidance"],
    cons: ["Oversimplification", "Not binary choices", "Context-dependent"],
  },
  {
    id: "acid",
    name: "ACID Transactions",
    category: "Data Management",
    shortDesc: "Atomicity, Consistency, Isolation, Durability",
    description: "ACID properties ensure database transactions are processed reliably. They guarantee that transactions are atomic, consistent, isolated, and durable.",
    useCases: ["Financial systems", "Order processing", "Inventory management"],
    pros: ["Data integrity", "Reliability", "Predictability"],
    cons: ["Performance overhead", "Scalability limits", "Lock contention"],
  },
  {
    id: "base",
    name: "BASE Model",
    category: "Data Management",
    shortDesc: "Basically Available, Soft state, Eventually consistent",
    description: "BASE is an alternative to ACID that prioritizes availability over consistency. It's commonly used in distributed systems where high availability is crucial.",
    useCases: ["NoSQL databases", "Large-scale web apps", "Real-time systems"],
    pros: ["High availability", "Scalability", "Performance"],
    cons: ["Eventual consistency", "Complex reasoning", "Conflict handling"],
  },
  {
    id: "idempotency",
    name: "Idempotency",
    category: "Reliability",
    shortDesc: "Operations produce same result regardless of repetition",
    description: "An idempotent operation can be applied multiple times without changing the result beyond the initial application. This is crucial for handling retries and ensuring data consistency.",
    useCases: ["Payment processing", "API design", "Message handling"],
    pros: ["Safe retries", "Simplifies error handling", "Data consistency"],
    cons: ["Implementation complexity", "Storage for tracking", "Performance overhead"],
  },
  {
    id: "two-phase-commit",
    name: "Two-Phase Commit",
    category: "Data Management",
    shortDesc: "Coordinate distributed transactions",
    description: "Two-phase commit (2PC) is a protocol ensuring all participants in a distributed transaction either commit or abort. It provides atomicity across multiple nodes.",
    useCases: ["Distributed databases", "Microservices transactions", "Financial systems"],
    pros: ["Atomicity guarantee", "Consistency", "Coordination"],
    cons: ["Blocking protocol", "Single point of failure", "Performance impact"],
  },
  {
    id: "saga-pattern",
    name: "Saga Pattern",
    category: "Data Management",
    shortDesc: "Manage distributed transactions via compensating actions",
    description: "The Saga pattern manages data consistency in microservices by using a sequence of local transactions. If one fails, compensating transactions undo preceding changes.",
    useCases: ["E-commerce orders", "Booking systems", "Multi-service workflows"],
    pros: ["No distributed locks", "Scalability", "Loose coupling"],
    cons: ["Complexity", "Compensating logic", "Eventual consistency"],
  },
  {
    id: "cqrs",
    name: "CQRS",
    category: "Architecture",
    shortDesc: "Separate read and write operations",
    description: "Command Query Responsibility Segregation separates read and write operations into different models. This allows independent optimization and scaling of each side.",
    useCases: ["Complex domains", "High-performance reads", "Event sourcing"],
    pros: ["Optimized models", "Scalability", "Separation of concerns"],
    cons: ["Complexity", "Eventual consistency", "More code"],
  },
  {
    id: "event-sourcing",
    name: "Event Sourcing",
    category: "Architecture",
    shortDesc: "Store state changes as sequence of events",
    description: "Event sourcing stores all changes to application state as a sequence of events. The current state is derived by replaying these events.",
    useCases: ["Audit logs", "Financial systems", "Temporal queries"],
    pros: ["Complete audit trail", "Time travel", "Event replay"],
    cons: ["Complexity", "Storage requirements", "Event versioning"],
  },
  {
    id: "service-mesh",
    name: "Service Mesh",
    category: "Architecture",
    shortDesc: "Infrastructure layer for service-to-service communication",
    description: "A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It provides features like load balancing, encryption, and observability.",
    useCases: ["Kubernetes environments", "Microservices", "Zero-trust networking"],
    pros: ["Observability", "Security", "Traffic management"],
    cons: ["Complexity", "Resource overhead", "Learning curve"],
  },
  {
    id: "sidecar-pattern",
    name: "Sidecar Pattern",
    category: "Architecture",
    shortDesc: "Deploy helper components alongside main application",
    description: "The sidecar pattern deploys helper components as separate processes or containers alongside the main application. It extends functionality without modifying the core service.",
    useCases: ["Logging", "Monitoring", "Proxy services"],
    pros: ["Separation of concerns", "Reusability", "Independent updates"],
    cons: ["Resource overhead", "Complexity", "Latency"],
  },
  {
    id: "backpressure",
    name: "Backpressure",
    category: "Reliability",
    shortDesc: "Control data flow when consumers can't keep up",
    description: "Backpressure is a mechanism for controlling data flow when a consumer cannot process data as fast as it's produced. It prevents memory overflow and system crashes.",
    useCases: ["Streaming systems", "Message queues", "Real-time processing"],
    pros: ["Prevents overflow", "System stability", "Resource protection"],
    cons: ["Complexity", "Latency", "Flow control overhead"],
  },
  {
    id: "bulkhead",
    name: "Bulkhead Pattern",
    category: "Reliability",
    shortDesc: "Isolate failures to prevent system-wide impact",
    description: "The bulkhead pattern isolates elements of an application into pools so that if one fails, the others continue functioning. It's named after ship compartments.",
    useCases: ["Microservices", "Multi-tenant systems", "Resource pools"],
    pros: ["Fault isolation", "Graceful degradation", "Resource protection"],
    cons: ["Resource overhead", "Complexity", "Sizing challenges"],
  },
  {
    id: "retry-pattern",
    name: "Retry Pattern",
    category: "Reliability",
    shortDesc: "Automatically retry failed operations",
    description: "The retry pattern enables an application to retry a failed operation with the expectation that it might succeed on a subsequent attempt. Often combined with exponential backoff.",
    useCases: ["Network calls", "Database operations", "External APIs"],
    pros: ["Handles transient failures", "Improves reliability", "Simple implementation"],
    cons: ["Can amplify load", "Delay accumulation", "Idempotency required"],
  },
  {
    id: "timeout-pattern",
    name: "Timeout Pattern",
    category: "Reliability",
    shortDesc: "Set time limits on operations",
    description: "The timeout pattern sets a maximum time for operations to complete. It prevents resources from being held indefinitely and enables faster failure detection.",
    useCases: ["API calls", "Database queries", "External services"],
    pros: ["Resource protection", "Fast failure", "Predictable behavior"],
    cons: ["Tuning difficulty", "False failures", "Cascading timeouts"],
  },
  {
    id: "health-checks",
    name: "Health Checks",
    category: "Reliability",
    shortDesc: "Monitor service health and readiness",
    description: "Health checks are endpoints that report the operational status of a service. They enable load balancers and orchestrators to route traffic and restart unhealthy instances.",
    useCases: ["Load balancers", "Kubernetes", "Monitoring systems"],
    pros: ["Automatic recovery", "Traffic routing", "Early detection"],
    cons: ["False positives", "Check overhead", "Dependency checks"],
  },
  {
    id: "graceful-degradation",
    name: "Graceful Degradation",
    category: "Reliability",
    shortDesc: "Maintain partial functionality during failures",
    description: "Graceful degradation allows a system to continue operating with reduced functionality when some components fail, rather than failing completely.",
    useCases: ["E-commerce sites", "Streaming services", "Critical applications"],
    pros: ["Better UX", "Partial availability", "Business continuity"],
    cons: ["Complex implementation", "Testing difficulty", "Feature prioritization"],
  },
  {
    id: "write-ahead-log",
    name: "Write-Ahead Logging",
    category: "Data Management",
    shortDesc: "Log changes before applying them",
    description: "Write-ahead logging (WAL) records changes to a log before applying them to the database. This ensures durability and enables recovery after crashes.",
    useCases: ["Databases", "File systems", "Transaction systems"],
    pros: ["Crash recovery", "Durability", "Performance"],
    cons: ["Storage overhead", "Write amplification", "Log management"],
  },
  {
    id: "consistent-hashing",
    name: "Consistent Hashing",
    category: "Data Management",
    shortDesc: "Distribute data with minimal redistribution",
    description: "Consistent hashing distributes data across nodes in a way that minimizes redistribution when nodes are added or removed. It's essential for distributed caching and databases.",
    useCases: ["Distributed caching", "Load balancing", "Distributed databases"],
    pros: ["Minimal redistribution", "Scalability", "Even distribution"],
    cons: ["Hotspots possible", "Virtual nodes needed", "Complexity"],
  },
  {
    id: "bloom-filter",
    name: "Bloom Filter",
    category: "Data Management",
    shortDesc: "Probabilistic data structure for set membership",
    description: "A Bloom filter is a space-efficient probabilistic data structure that tests whether an element is a member of a set. False positives are possible, but false negatives are not.",
    useCases: ["Cache lookup", "Spell checkers", "Database queries"],
    pros: ["Space efficient", "Fast lookups", "No false negatives"],
    cons: ["False positives", "No deletion", "Probability tuning"],
  },
  {
    id: "leader-election",
    name: "Leader Election",
    category: "Architecture",
    shortDesc: "Designate a single coordinator among nodes",
    description: "Leader election algorithms choose a single node as the coordinator for a distributed system. The leader handles critical operations like writes or coordination.",
    useCases: ["Distributed databases", "Consensus systems", "Cluster coordination"],
    pros: ["Single coordinator", "Consistency", "Simplified logic"],
    cons: ["Single point of failure", "Election overhead", "Split-brain risk"],
  },
  {
    id: "consensus",
    name: "Consensus Algorithms",
    category: "Architecture",
    shortDesc: "Achieve agreement among distributed nodes",
    description: "Consensus algorithms enable distributed systems to agree on a single value or state. Popular algorithms include Paxos, Raft, and PBFT.",
    useCases: ["Distributed databases", "Blockchain", "Configuration management"],
    pros: ["Strong consistency", "Fault tolerance", "Coordination"],
    cons: ["Latency", "Complexity", "Network partition handling"],
  },
  {
    id: "gossip-protocol",
    name: "Gossip Protocol",
    category: "Communication",
    shortDesc: "Spread information through random peer exchange",
    description: "Gossip protocols spread information through a network by having each node periodically exchange information with random peers. It's resilient and eventually consistent.",
    useCases: ["Cluster membership", "Failure detection", "Data dissemination"],
    pros: ["Scalability", "Fault tolerance", "Simplicity"],
    cons: ["Eventual consistency", "Bandwidth usage", "Convergence time"],
  },
  {
    id: "read-replica",
    name: "Read Replicas",
    category: "Data Management",
    shortDesc: "Scale reads by replicating to multiple servers",
    description: "Read replicas are copies of a primary database that handle read queries. They improve read performance and reduce load on the primary database.",
    useCases: ["Read-heavy workloads", "Reporting", "Geographic distribution"],
    pros: ["Read scalability", "Reduced primary load", "High availability"],
    cons: ["Replication lag", "Consistency issues", "Cost"],
  },
  {
    id: "write-through-cache",
    name: "Write-Through Cache",
    category: "Caching",
    shortDesc: "Write to cache and database simultaneously",
    description: "Write-through caching writes data to both the cache and the underlying storage simultaneously. It ensures cache consistency but has write latency.",
    useCases: ["Financial systems", "Inventory", "Critical data"],
    pros: ["Cache consistency", "Data durability", "Simplified reads"],
    cons: ["Write latency", "Write overhead", "Cache size"],
  },
  {
    id: "write-behind-cache",
    name: "Write-Behind Cache",
    category: "Caching",
    shortDesc: "Write to cache immediately, persist later",
    description: "Write-behind (write-back) caching writes to the cache immediately and asynchronously persists to the database. It improves write performance but risks data loss.",
    useCases: ["High-write workloads", "Logging", "Session data"],
    pros: ["Fast writes", "Reduced database load", "Batching"],
    cons: ["Data loss risk", "Complexity", "Consistency"],
  },
  {
    id: "cache-aside",
    name: "Cache-Aside Pattern",
    category: "Caching",
    shortDesc: "Application manages cache population",
    description: "In the cache-aside pattern, the application is responsible for loading data into the cache. On a cache miss, it reads from the database and populates the cache.",
    useCases: ["General caching", "Read-heavy workloads", "Flexible caching"],
    pros: ["Flexibility", "Only cache what's needed", "Database fallback"],
    cons: ["Cache miss penalty", "Stale data", "Application complexity"],
  },
  {
    id: "pub-sub",
    name: "Publish-Subscribe",
    category: "Communication",
    shortDesc: "Decouple senders and receivers via topics",
    description: "Publish-subscribe is a messaging pattern where publishers send messages to topics without knowing subscribers. Subscribers receive messages from topics they're interested in.",
    useCases: ["Event notifications", "Real-time updates", "Microservices"],
    pros: ["Loose coupling", "Scalability", "Flexibility"],
    cons: ["Message ordering", "Delivery guarantees", "Debugging"],
  },
  {
    id: "request-response",
    name: "Request-Response",
    category: "Communication",
    shortDesc: "Synchronous communication pattern",
    description: "Request-response is a synchronous communication pattern where a client sends a request and waits for a response. It's simple but creates tight coupling.",
    useCases: ["REST APIs", "RPC", "Database queries"],
    pros: ["Simple model", "Immediate feedback", "Error handling"],
    cons: ["Tight coupling", "Latency", "Scalability limits"],
  },
  {
    id: "reverse-proxy",
    name: "Reverse Proxy",
    category: "Architecture",
    shortDesc: "Intermediate server handling client requests",
    description: "A reverse proxy sits between clients and servers, forwarding client requests to appropriate backend servers. It can provide load balancing, SSL termination, and caching.",
    useCases: ["Web servers", "API gateways", "Security"],
    pros: ["Load balancing", "SSL termination", "Caching"],
    cons: ["Single point of failure", "Added latency", "Complexity"],
  },
  {
    id: "connection-pooling",
    name: "Connection Pooling",
    category: "Performance",
    shortDesc: "Reuse database connections",
    description: "Connection pooling maintains a pool of reusable database connections. It eliminates the overhead of creating new connections for each request.",
    useCases: ["Database access", "HTTP clients", "Resource management"],
    pros: ["Performance", "Resource efficiency", "Connection reuse"],
    cons: ["Pool sizing", "Connection leaks", "Stale connections"],
  },
  {
    id: "data-partitioning",
    name: "Data Partitioning",
    category: "Data Management",
    shortDesc: "Divide data into independent segments",
    description: "Data partitioning divides a database into distinct, independent parts. Each partition can be managed and accessed separately, improving performance and manageability.",
    useCases: ["Large databases", "Multi-tenant systems", "Time-series data"],
    pros: ["Performance", "Manageability", "Scalability"],
    cons: ["Query complexity", "Rebalancing", "Cross-partition operations"],
  },
  {
    id: "throttling",
    name: "Throttling",
    category: "Performance",
    shortDesc: "Limit resource consumption rate",
    description: "Throttling controls the rate at which an application consumes resources. It prevents system overload and ensures fair resource distribution among users.",
    useCases: ["API rate limiting", "Resource management", "Traffic control"],
    pros: ["Prevents overload", "Fair usage", "Cost control"],
    cons: ["User impact", "Configuration", "Granularity"],
  },
  {
    id: "dns-load-balancing",
    name: "DNS Load Balancing",
    category: "Scalability",
    shortDesc: "Distribute traffic at DNS level",
    description: "DNS load balancing distributes traffic by returning different IP addresses for the same domain name. It's simple but has limited control over traffic distribution.",
    useCases: ["Global load balancing", "CDN routing", "Simple distribution"],
    pros: ["Simple", "Global reach", "No infrastructure"],
    cons: ["Limited control", "DNS caching", "No health checks"],
  },
  {
    id: "zero-trust",
    name: "Zero Trust Security",
    category: "Security",
    shortDesc: "Never trust, always verify",
    description: "Zero trust security assumes no implicit trust and requires verification for every access request. It protects against both external and internal threats.",
    useCases: ["Enterprise security", "Cloud environments", "Remote work"],
    pros: ["Strong security", "Breach containment", "Compliance"],
    cons: ["Complexity", "User friction", "Implementation cost"],
  },
];
